#include <FastLED.h>
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
//#include <SD.h>
//#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioSynthNoiseWhite     noise;        //xy=1217.7329330444336,2750.732503890991
AudioSynthWaveform       lfoVoice;       //xy=1227.7327423095703,2415.7328128814697
AudioSynthWaveform       lfoFilter;      //xy=1230.7329177856445,2505.732847213745
AudioSynthWaveform       voicea8;        //xy=1826.7328758239746,3266.732723236084
AudioSynthWaveformModulated voiceb7;   //xy=1865.5511932373047,3035.9143676757812
AudioSynthWaveformModulated voiceb5;   //xy=1873.5511016845703,2405.460273742676
AudioSynthWaveformModulated voiceb6;   //xy=1883.551124572754,2705.1874952316284
AudioSynthWaveformModulated voiceb1;   //xy=1889.5511932373047,1317.3692569732666
AudioSynthWaveformModulated voiceb4;   //xy=1887.5511474609375,2121.914840698242
AudioSynthWaveformModulated voiceb8;   //xy=1887.5511016845703,3323.641914367676
AudioSynthWaveformModulated voiceb2;   //xy=1899.5511932373047,1595.3693284988403
AudioSynthWaveformModulated voiceb3;   //xy=1904.5512351989746,1886.0964317321777
AudioSynthWaveform       voicea7;        //xy=1904.7329177856445,2967.732847213745
AudioSynthWaveform       voicea5;        //xy=1914.7329177856445,2348.732847213745
AudioSynthWaveform       voicea6;        //xy=1915.7329177856445,2654.732847213745
AudioSynthWaveform       voicea4;        //xy=1920.7329177856445,2064.732847213745
AudioSynthWaveform       voicea2;        //xy=1930.7329177856445,1536.7328472137451
AudioSynthWaveform       voicea1;        //xy=1933.7329177856445,1247.7328472137451
AudioSynthWaveform       voicea3;        //xy=1938.7329177856445,1819.7328472137451
AudioSynthWaveformDc     voicefilterenv8; //xy=2003.7329177856445,3464.732847213745
AudioSynthWaveformDc     voicefilterenv7; //xy=2022.7329177856445,3160.732847213745
AudioSynthWaveformDc     voiceenv8;      //xy=2026.7329177856445,3399.732847213745
AudioSynthWaveformDc     voicefilterenv5; //xy=2032.7329177856445,2541.732847213745
AudioSynthWaveformDc     voicefilterenv6; //xy=2033.7329177856445,2847.732847213745
AudioSynthWaveformDc     voicefilterenv4; //xy=2038.7329177856445,2257.732847213745
AudioSynthWaveformDc     voicefilterenv2; //xy=2048.7329177856445,1728.7328472137451
AudioSynthWaveformDc     voicefilterenv1; //xy=2050.7329177856445,1439.7328472137451
AudioMixer4              voicemix7;      //xy=2044.7329177856445,3030.732847213745
AudioMixer4              voicemix8;      //xy=2044.7328758239746,3291.7327671051025
AudioSynthWaveformDc     voiceenv7;      //xy=2045.7329177856445,3095.732847213745
AudioSynthWaveformDc     voicefilterenv3; //xy=2055.7329177856445,2012.7328472137451
AudioMixer4              voicemix5;      //xy=2054.7329177856445,2411.732847213745
AudioSynthWaveformDc     voiceenv5;      //xy=2055.7329177856445,2476.732847213745
AudioMixer4              voicemix6;      //xy=2055.7329177856445,2717.732847213745
AudioSynthWaveformDc     voiceenv6;      //xy=2056.7329177856445,2782.732847213745
AudioMixer4              voicemix4;      //xy=2060.7329177856445,2127.732847213745
AudioSynthWaveformDc     voiceenv4;      //xy=2061.7329177856445,2192.732847213745
AudioMixer4              voicemix2;      //xy=2070.7329177856445,1599.7328472137451
AudioSynthWaveformDc     voiceenv2;      //xy=2071.7329177856445,1664.7328472137451
AudioMixer4              voicemix1;      //xy=2073.7329177856445,1310.7328472137451
AudioSynthWaveformDc     voiceenv1;      //xy=2074.7329177856445,1375.7328472137451
AudioMixer4              voicemix3;      //xy=2078.7329177856445,1882.7328472137451
AudioSynthWaveformDc     voiceenv3;      //xy=2079.7329177856445,1947.7328472137451
AudioEffectMultiply      voicemultiply8; //xy=2189.7329177856445,3357.732847213745
AudioMixer4              voicefiltermodmixer8; //xy=2206.7329177856445,3482.732847213745
AudioEffectMultiply      voicemultiply7; //xy=2208.7329177856445,3053.732847213745
AudioEffectMultiply      voicemultiply5; //xy=2218.7329177856445,2434.732847213745
AudioEffectMultiply      voicemultiply6; //xy=2219.7329177856445,2740.732847213745
AudioEffectMultiply      voicemultiply4; //xy=2224.7329177856445,2150.732847213745
AudioMixer4              voicefiltermodmixer7; //xy=2225.7329177856445,3178.732847213745
AudioEffectMultiply      voicemultiply2; //xy=2234.7329177856445,1622.7328472137451
AudioEffectMultiply      voicemultiply1; //xy=2237.7329177856445,1333.7328472137451
AudioMixer4              voicefiltermodmixer5; //xy=2235.7329177856445,2559.732847213745
AudioMixer4              voicefiltermodmixer6; //xy=2236.7329177856445,2865.732847213745
AudioEffectMultiply      voicemultiply3; //xy=2242.7329177856445,1905.7328472137451
AudioMixer4              voicefiltermodmixer4; //xy=2241.7329177856445,2275.732847213745
AudioMixer4              voicefiltermodmixer2; //xy=2251.7329177856445,1747.7328472137451
AudioMixer4              voicefiltermodmixer1; //xy=2254.7329177856445,1458.7328472137451
AudioMixer4              voicefiltermodmixer3; //xy=2259.7329177856445,2030.7328472137451
AudioFilterStateVariable voicefilter8;   //xy=2392.7329177856445,3424.732847213745
AudioFilterStateVariable voicefilter7;   //xy=2411.7329177856445,3120.732847213745
AudioFilterStateVariable voicefilter5;   //xy=2421.7329177856445,2501.732847213745
AudioFilterStateVariable voicefilter6;   //xy=2422.7329177856445,2807.732847213745
AudioFilterStateVariable voicefilter4;   //xy=2427.7329177856445,2217.732847213745
AudioFilterStateVariable voicefilter2;   //xy=2437.7329177856445,1689.7328472137451
AudioFilterStateVariable voicefilter1;   //xy=2440.7329177856445,1400.7328472137451
AudioFilterStateVariable voicefilter3;   //xy=2445.7329177856445,1972.7328472137451
AudioMixer4              last4premix1;   //xy=2842.7329177856445,2606.732847213745
AudioMixer4              last4premix;    //xy=2844.7329177856445,2523.732847213745
AudioMixer4              first4premix;   //xy=2845.7329177856445,2439.732847213745
AudioMixer4              last4premix2;   //xy=3134.7329177856445,2521.732847213745
AudioEffectDelay         delay1;         //xy=3339.7329177856445,2976.732847213745
AudioMixer4              mainOutMixer;   //xy=3365.7329177856445,2516.732847213745
AudioFilterStateVariable delayFilter;    //xy=3527.7329177856445,2937.732847213745
AudioAmplifier           ampLeft;        //xy=3663.7329177856445,2439.732847213745
AudioAmplifier           ampRight;       //xy=3663.7329177856445,2490.732847213745
AudioOutputI2S           i2s1;           //xy=3838.7329177856445,2465.732847213745
AudioConnection          patchCord1(noise, 0, voicemix1, 2);
AudioConnection          patchCord2(noise, 0, voicemix2, 2);
AudioConnection          patchCord3(noise, 0, voicemix3, 2);
AudioConnection          patchCord4(noise, 0, voicemix4, 2);
AudioConnection          patchCord5(noise, 0, voicemix5, 2);
AudioConnection          patchCord6(noise, 0, voicemix6, 2);
AudioConnection          patchCord7(noise, 0, voicemix7, 2);
AudioConnection          patchCord8(noise, 0, voicemix8, 2);
AudioConnection          patchCord9(lfoVoice, 0, voiceb1, 0);
AudioConnection          patchCord10(lfoVoice, 0, voiceb2, 0);
AudioConnection          patchCord11(lfoVoice, 0, voiceb3, 0);
AudioConnection          patchCord12(lfoVoice, 0, voiceb4, 0);
AudioConnection          patchCord13(lfoVoice, 0, voiceb5, 0);
AudioConnection          patchCord14(lfoVoice, 0, voiceb6, 0);
AudioConnection          patchCord15(lfoVoice, 0, voiceb7, 0);
AudioConnection          patchCord16(lfoVoice, 0, voiceb8, 0);
AudioConnection          patchCord17(lfoFilter, 0, voicefiltermodmixer1, 1);
AudioConnection          patchCord18(lfoFilter, 0, voicefiltermodmixer2, 1);
AudioConnection          patchCord19(lfoFilter, 0, voicefiltermodmixer3, 1);
AudioConnection          patchCord20(lfoFilter, 0, voicefiltermodmixer4, 1);
AudioConnection          patchCord21(lfoFilter, 0, voicefiltermodmixer5, 1);
AudioConnection          patchCord22(lfoFilter, 0, voicefiltermodmixer6, 1);
AudioConnection          patchCord23(lfoFilter, 0, voicefiltermodmixer7, 1);
AudioConnection          patchCord24(lfoFilter, 0, voicefiltermodmixer8, 1);
AudioConnection          patchCord25(voicea8, 0, voicemix8, 0);
AudioConnection          patchCord26(voiceb7, 0, voicemix7, 1);
AudioConnection          patchCord27(voiceb5, 0, voicemix5, 1);
AudioConnection          patchCord28(voiceb6, 0, voicemix6, 1);
AudioConnection          patchCord29(voiceb1, 0, voicemix1, 1);
AudioConnection          patchCord30(voiceb4, 0, voicemix4, 1);
AudioConnection          patchCord31(voiceb8, 0, voicemix8, 1);
AudioConnection          patchCord32(voiceb2, 0, voicemix2, 1);
AudioConnection          patchCord33(voiceb3, 0, voicemix3, 1);
AudioConnection          patchCord34(voicea7, 0, voicemix7, 0);
AudioConnection          patchCord35(voicea5, 0, voicemix5, 0);
AudioConnection          patchCord36(voicea6, 0, voicemix6, 0);
AudioConnection          patchCord37(voicea4, 0, voicemix4, 0);
AudioConnection          patchCord38(voicea2, 0, voicemix2, 0);
AudioConnection          patchCord39(voicea1, 0, voicemix1, 0);
AudioConnection          patchCord40(voicea3, 0, voicemix3, 0);
AudioConnection          patchCord41(voicefilterenv8, 0, voicefiltermodmixer8, 0);
AudioConnection          patchCord42(voicefilterenv7, 0, voicefiltermodmixer7, 0);
AudioConnection          patchCord43(voiceenv8, 0, voicemultiply8, 1);
AudioConnection          patchCord44(voicefilterenv5, 0, voicefiltermodmixer5, 0);
AudioConnection          patchCord45(voicefilterenv6, 0, voicefiltermodmixer6, 0);
AudioConnection          patchCord46(voicefilterenv4, 0, voicefiltermodmixer4, 0);
AudioConnection          patchCord47(voicefilterenv2, 0, voicefiltermodmixer2, 0);
AudioConnection          patchCord48(voicefilterenv1, 0, voicefiltermodmixer1, 0);
AudioConnection          patchCord49(voicemix7, 0, voicemultiply7, 0);
AudioConnection          patchCord50(voicemix8, 0, voicemultiply8, 0);
AudioConnection          patchCord51(voiceenv7, 0, voicemultiply7, 1);
AudioConnection          patchCord52(voicefilterenv3, 0, voicefiltermodmixer3, 0);
AudioConnection          patchCord53(voicemix5, 0, voicemultiply5, 0);
AudioConnection          patchCord54(voiceenv5, 0, voicemultiply5, 1);
AudioConnection          patchCord55(voicemix6, 0, voicemultiply6, 0);
AudioConnection          patchCord56(voiceenv6, 0, voicemultiply6, 1);
AudioConnection          patchCord57(voicemix4, 0, voicemultiply4, 0);
AudioConnection          patchCord58(voiceenv4, 0, voicemultiply4, 1);
AudioConnection          patchCord59(voicemix2, 0, voicemultiply2, 0);
AudioConnection          patchCord60(voiceenv2, 0, voicemultiply2, 1);
AudioConnection          patchCord61(voicemix1, 0, voicemultiply1, 0);
AudioConnection          patchCord62(voiceenv1, 0, voicemultiply1, 1);
AudioConnection          patchCord63(voicemix3, 0, voicemultiply3, 0);
AudioConnection          patchCord64(voiceenv3, 0, voicemultiply3, 1);
AudioConnection          patchCord65(voicemultiply8, 0, voicefilter8, 0);
AudioConnection          patchCord66(voicefiltermodmixer8, 0, voicefilter8, 1);
AudioConnection          patchCord67(voicemultiply7, 0, voicefilter7, 0);
AudioConnection          patchCord68(voicemultiply5, 0, voicefilter5, 0);
AudioConnection          patchCord69(voicemultiply6, 0, voicefilter6, 0);
AudioConnection          patchCord70(voicemultiply4, 0, voicefilter4, 0);
AudioConnection          patchCord71(voicefiltermodmixer7, 0, voicefilter7, 1);
AudioConnection          patchCord72(voicemultiply2, 0, voicefilter2, 0);
AudioConnection          patchCord73(voicemultiply1, 0, voicefilter1, 0);
AudioConnection          patchCord74(voicefiltermodmixer5, 0, voicefilter5, 1);
AudioConnection          patchCord75(voicefiltermodmixer6, 0, voicefilter6, 1);
AudioConnection          patchCord76(voicemultiply3, 0, voicefilter3, 0);
AudioConnection          patchCord77(voicefiltermodmixer4, 0, voicefilter4, 1);
AudioConnection          patchCord78(voicefiltermodmixer2, 0, voicefilter2, 1);
AudioConnection          patchCord79(voicefiltermodmixer1, 0, voicefilter1, 1);
AudioConnection          patchCord80(voicefiltermodmixer3, 0, voicefilter3, 1);
AudioConnection          patchCord81(voicefilter8, 0, last4premix, 3);
AudioConnection          patchCord82(voicefilter7, 0, last4premix, 2);
AudioConnection          patchCord83(voicefilter5, 0, last4premix, 0);
AudioConnection          patchCord84(voicefilter6, 0, last4premix, 1);
AudioConnection          patchCord85(voicefilter4, 0, first4premix, 3);
AudioConnection          patchCord86(voicefilter2, 0, first4premix, 1);
AudioConnection          patchCord87(voicefilter1, 0, first4premix, 0);
AudioConnection          patchCord88(voicefilter3, 0, first4premix, 2);
AudioConnection          patchCord89(last4premix1, 0, last4premix2, 2);
AudioConnection          patchCord90(last4premix, 0, last4premix2, 1);
AudioConnection          patchCord91(first4premix, 0, last4premix2, 0);
AudioConnection          patchCord92(last4premix2, 0, mainOutMixer, 2);
AudioConnection          patchCord93(delay1, 0, delayFilter, 0);
AudioConnection          patchCord94(mainOutMixer, delay1);
AudioConnection          patchCord95(mainOutMixer, ampRight);
AudioConnection          patchCord96(mainOutMixer, ampLeft);
AudioConnection          patchCord97(delayFilter, 0, mainOutMixer, 3);
AudioConnection          patchCord98(ampLeft, 0, i2s1, 0);
AudioConnection          patchCord99(ampRight, 0, i2s1, 1);
AudioControlSGTL5000     sgtl5000_1;     //xy=3328.7329177856445,2283.732847213745
// GUItool: end automatically generated code

#define NUM_LEDS 13
#define NUM_BUTTONS 13
#define NUM_VOICES 8
#define VERSION 4

//PINS
#define KEY_LEDS_PIN 17
#define DIGITAL_SPARE_PIN_0 5
#define DIGITAL_SPARE_PIN_1 8
#define ANALOG_SPARE_PIN_0 16

#define MUX_S0_PIN 4
#define MUX_S1_PIN 3
#define MUX_S2_PIN 2
#define MUX_S3_PIN 1

#define DIGITAL_MUX_IN_PIN 16
#define ANALOG_MUX_0_IN_PIN 21
#define ANALOG_MUX_1_IN_PIN 20

#define VOLUME_PIN 15

//ANALOG MUX addresses
#define VOICE_1_WAVEFORM 1, 15
#define VOICE_1_PULSE_WIDTH 1, 14
#define VOICE_1_OCTAVE 1, 13
#define VOICE_2_WAVEFORM 1, 12
#define VOICE_2_PULSE_WIDTH 1, 11
#define VOICE_2_OCTAVE 1, 10
#define VOICE_2_DETUNE 1, 9
#define VOICE_MIX 1, 8
#define VOICE_LFO 1, 7
#define VOICE_LFO_WAVEFORM 1, 6
#define VOICE_LFO_STRENGTH 1, 5
#define ENVELOPE_1 1, 4
#define ENVELOPE_2 1, 3
#define ENVELOPE_3 1, 2
#define ENVELOPE_4 1, 1
#define BALANCE 1, 0
#define FILTER_CUTOFF 0, 15
#define FILTER_RESONANCE 0, 14
#define FILTER_1 0, 13
#define FILTER_2 0, 12
#define FILTER_3 0, 11
#define FILTER_4 0, 10
#define FILTER_MIX 0, 9
#define FILTER_LFO 0, 8
#define FILTER_LFO_WAVEFORM 0, 7
#define FILTER_LFO_STRENGTH 0, 6
#define DELAY_TIME 0, 5
#define DELAY_FEEDBACK 0, 4
#define NOISE 0, 3
#define SPARE0 0, 2
#define SPARE1 0, 1
#define SPARE2 0, 0

#define NUM_DIGITAL_VALUES 6
short DigitalValues[NUM_DIGITAL_VALUES];
short LastDigitalValues[6];
#define voice_1_waveform 0
#define voice_1_octave 1
#define voice_2_waveform 2
#define voice_2_octave 3
#define voice_lfo_waveform 4
#define filter_lfo_waveform 5

#define NUM_ANALOG_VALUES 26
float AnalogValues[NUM_ANALOG_VALUES];
float LastAnalogValues[NUM_ANALOG_VALUES];
#define voice_1_pulse_width 0
#define voice_2_pulse_width 1
#define voice_2_detune 2
#define voice_mix 3
#define voice_lfo_frequency 4
#define voice_lfo_strength 5

#define attackTime 6
#define sustainLevel 7
#define decayTime 8
#define releaseTime 9

#define balance 10
#define filter_cutoff 11
#define filter_resonance 12

#define attackTimeFilter 13
#define sustainLevelFilter 14
#define decayTimeFilter 15
#define releaseTimeFilter 16

#define filter_mix 17
#define filter_lfo 18
#define filter_lfo_strength 19
#define delay_time 20
#define delay_feedback 21
#define noiseip 22
#define spare0 23
#define spare1 24
#define spare2 25

float notes[] = { 32.70320 , 34.64783 , 36.70810 , 38.89087, 41.20344, 43.65353, 46.24930, 48.99943, 51.91309, 55.00000, 58.27047, 61.73541, 65.40639 };

short WaveForms[5] = {
	WAVEFORM_SINE,
	WAVEFORM_SAWTOOTH,
	WAVEFORM_SAWTOOTH_REVERSE,
	WAVEFORM_PULSE,
	WAVEFORM_SAMPLE_HOLD,
};

void  PrintWaveform(short index)
{
	switch (index)
	{
	case WAVEFORM_SINE:
	{
		Serial.println("WAVEFORM_SINE");
		break;
	}
	case WAVEFORM_SAWTOOTH:
	{
		Serial.println("WAVEFORM_SAWTOOTH");
		break;
	}
	case WAVEFORM_SAWTOOTH_REVERSE:
	{
		Serial.println("WAVEFORM_SAWTOOTH_REVERSE");
		break;
	}
	case WAVEFORM_PULSE:
	{
		Serial.println("WAVEFORM_PULSE");
		break;
	}
	case WAVEFORM_SAMPLE_HOLD:
	{
		Serial.println("WAVEFORM_SAMPLE_HOLD");
		break;
	}
	}
}

float GetAnalogValue(int mux, int address)
{
	digitalWrite(MUX_S0_PIN, bitRead(address, 0));
	digitalWrite(MUX_S1_PIN, bitRead(address, 1));
	digitalWrite(MUX_S2_PIN, bitRead(address, 2));
	digitalWrite(MUX_S3_PIN, bitRead(address, 3));

	int muxPin = ANALOG_MUX_1_IN_PIN;
	if (mux == 0)
	{
		muxPin = ANALOG_MUX_0_IN_PIN;
	}

	float sum = 0;
	for (size_t i = 0; i < 20; i++)
	{
		sum += analogRead(muxPin);
	}
	return sum / 20;
}

CRGB leds[NUM_LEDS];

int keyLightMap[] = { 12, 0, 11, 1, 10, 9, 2, 8, 3, 7, 4, 6, 5 };

void SetKeyLight(int key, CRGB colour)
{
	leds[keyLightMap[key]] = colour;
}

bool GetKeyInput(int address)
{
	if (address < 16)
	{
		digitalWrite(MUX_S0_PIN, bitRead(address, 0));
		digitalWrite(MUX_S1_PIN, bitRead(address, 1));
		digitalWrite(MUX_S2_PIN, bitRead(address, 2));
		digitalWrite(MUX_S3_PIN, bitRead(address, 3));

		return analogRead(DIGITAL_MUX_IN_PIN) < 900;
	}
	else
	{
		Serial.println("Error GetDigitalInput() parameter out of range");
	}

	return false;
}

float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void GetAnalogValues()
{
	DigitalValues[voice_1_waveform] = GetVoiceWaveForm(GetAnalogValue(VOICE_1_WAVEFORM));
	AnalogValues[voice_1_pulse_width] = GetAnalogValue(VOICE_1_PULSE_WIDTH);
	DigitalValues[voice_1_octave] = GetOctave(GetAnalogValue(VOICE_1_OCTAVE));
	DigitalValues[voice_2_waveform] = GetVoiceWaveForm(GetAnalogValue(VOICE_2_WAVEFORM));
	AnalogValues[voice_2_pulse_width] = GetAnalogValue(VOICE_2_PULSE_WIDTH);
	DigitalValues[voice_2_octave] = GetOctave(GetAnalogValue(VOICE_2_OCTAVE));
	AnalogValues[voice_2_detune] = GetAnalogValue(VOICE_2_DETUNE);
	AnalogValues[voice_mix] = GetAnalogValue(VOICE_MIX);
	AnalogValues[voice_lfo_frequency] = GetAnalogValue(VOICE_LFO);
	DigitalValues[voice_lfo_waveform] = GetLFOWaveForm(GetAnalogValue(VOICE_LFO_WAVEFORM));
	AnalogValues[voice_lfo_strength] = GetAnalogValue(VOICE_LFO_STRENGTH);
	AnalogValues[attackTime] = GetAnalogValue(ENVELOPE_1) * 2;
	AnalogValues[attackTimeFilter] = GetAnalogValue(FILTER_1) * 2;

	AnalogValues[sustainLevel] = GetAnalogValue(ENVELOPE_2) / 1023;
	AnalogValues[sustainLevelFilter] = mapfloat(GetAnalogValue(FILTER_2), 0, 1023, -1, 1);

	AnalogValues[decayTime] = GetAnalogValue(ENVELOPE_3);
	AnalogValues[decayTimeFilter] = GetAnalogValue(FILTER_3);

	AnalogValues[releaseTime] = GetAnalogValue(ENVELOPE_4) * 2;
	AnalogValues[releaseTimeFilter] = GetAnalogValue(FILTER_4) * 2;

	AnalogValues[balance] = GetAnalogValue(BALANCE);
	AnalogValues[filter_cutoff] = GetAnalogValue(FILTER_CUTOFF);
	AnalogValues[filter_resonance] = GetAnalogValue(FILTER_RESONANCE);
	AnalogValues[filter_mix] = GetAnalogValue(FILTER_MIX);
	AnalogValues[filter_lfo] = GetAnalogValue(FILTER_LFO);
	DigitalValues[filter_lfo_waveform] = GetLFOWaveForm(GetAnalogValue(FILTER_LFO_WAVEFORM));
	AnalogValues[filter_lfo_strength] = GetAnalogValue(FILTER_LFO_STRENGTH);
	AnalogValues[delay_time] = GetAnalogValue(DELAY_TIME);
	AnalogValues[delay_feedback] = GetAnalogValue(DELAY_FEEDBACK);
	AnalogValues[noiseip] = GetAnalogValue(NOISE);
	//GetAnalogValue(SPARE0);v
	//GetAnalogValue(SPARE1);
	//GetAnalogValue(SPARE2);
}

//void PrintValues()
//{
//	Serial.println();
//	Serial.println();
//	Serial.println();
//	Serial.println();
//	Serial.println("Values");
//	Serial.println("=========================");
//
//	Serial.print("voice_1_waveform ");
//	PrintWaveform(voice_1_waveform);
//	Serial.println(voice_1_pulse_width);
//	Serial.print("voice_1_octave "); Serial.println(voice_1_octave);
//	Serial.print("voice_2_waveform "); PrintWaveform(voice_2_waveform);
//	Serial.println(voice_2_pulse_width);
//	Serial.print("voice_2_octave "); Serial.println(voice_2_octave);
//	Serial.println(voice_2_detune);
//	Serial.println(voice_mix);
//	Serial.println(voice_lfo_frequency);
//	Serial.print("voice_lfo_waveform "); PrintWaveform(voice_lfo_waveform);
//	Serial.println(voice_lfo_strength);
//	Serial.println(attackTime);
//	Serial.println(sustainLevel);
//	Serial.println(decayTime);
//	Serial.println(releaseTime);
//	Serial.println(envelope_mix);
//	Serial.println(filter_cutoff);
//	Serial.println(filter_resonance);
//	Serial.println(attackTimeFilter);
//	Serial.println(sustainLevelFilter);
//	Serial.println(decayTimeFilter);
//	Serial.println(releaseTimeFilter);
//	Serial.println(filter_mix);
//	Serial.println(filter_lfo);
//	Serial.print("filter_lfo_waveform "); PrintWaveform(filter_lfo_waveform);
//	Serial.println(filter_lfo_strength);
//	Serial.println(delay_time);
//	Serial.println(delay_feedback);
//	Serial.println(noise);
//	//Serial.println(spare0);
//	//Serial.println(spare1);
//	//Serial.println(spare2);
//}

uint32_t attackWait[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
uint32_t releaseWait[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
bool noteTrigFlag[] = { false, false, false, false, false, false, false, false, false, false, false, false, false };
bool ButtonState[] = { false, false, false, false, false, false, false, false, false, false, false, false, false };
bool LastButtonState[] = { false, false, false, false, false, false, false, false, false, false, false, false, false };

AudioSynthWaveform* voices1[] = { &voicea1, &voicea2,&voicea3,&voicea4,&voicea5,&voicea6,&voicea7,&voicea8 };
AudioSynthWaveformModulated* voices2[] = { &voiceb1, &voiceb2, &voiceb3, &voiceb4, &voiceb5, &voiceb6, &voiceb7, &voiceb8 };
AudioSynthWaveformDc* filters[] = { &voicefilterenv1, &voicefilterenv2, &voicefilterenv4, &voicefilterenv4, &voicefilterenv5, &voicefilterenv6, &voicefilterenv7, &voicefilterenv8 };
AudioSynthWaveformDc* envelopes[] = { &voiceenv1,&voiceenv2,&voiceenv3,&voiceenv4,&voiceenv5,&voiceenv6,&voiceenv7,&voiceenv8 };
AudioMixer4* voiceMixs[] = { &voicemix1, &voicemix2, &voicemix3, &voicemix4, &voicemix5, &voicemix6, &voicemix7, &voicemix8 };
AudioFilterStateVariable* voiceFilters[] = { &voicefilter1,&voicefilter2,&voicefilter3,&voicefilter4,&voicefilter5,&voicefilter6,&voicefilter7,&voicefilter8 };
AudioMixer4* voiceFilterModmixers[] = { &voicefiltermodmixer1, &voicefiltermodmixer2, &voicefiltermodmixer3, &voicefiltermodmixer4, &voicefiltermodmixer5, &voicefiltermodmixer6, &voicefiltermodmixer7, &voicefiltermodmixer8 };

bool IsVoiceAllocated[NUM_VOICES];
int ButtonVoiceAllocation[NUM_BUTTONS];
#define memblock 160

void setup() {
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		ButtonVoiceAllocation[i] = -1;
	}
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		IsVoiceAllocated[i] = false;
	}

	Serial.begin(115200); // use the serial port
	Serial.print("Version ");
	Serial.println(VERSION);

	for (size_t i = 0; i < NUM_ANALOG_VALUES; i++)
	{
		LastAnalogValues[i] = -100;
	}
	for (size_t i = 0; i < NUM_DIGITAL_VALUES; i++)
	{
		LastDigitalValues[i] = -100;
	}
	static DMAMEM audio_block_t data[memblock];
	AudioStream::initialize_memory(data, memblock);

	sgtl5000_1.enable();
	sgtl5000_1.volume(.8);

	//key mixers
	first4premix.gain(0, .25);
	first4premix.gain(1, .25);
	first4premix.gain(2, .25);
	first4premix.gain(3, .25);

	last4premix.gain(0, .25);
	last4premix.gain(1, .25);
	last4premix.gain(2, .25);
	last4premix.gain(3, .25);

	last4premix1.gain(0, .25);
	last4premix1.gain(1, .25);
	last4premix1.gain(2, .25);
	last4premix1.gain(3, .25);

	//mix the prepre mixers
	last4premix2.gain(0, .25);
	last4premix2.gain(1, .25);
	last4premix2.gain(2, .25);
	last4premix2.gain(3, .25);

	//init the key voices
	//Voice 1
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		voices1[i]->begin(.9, 440, WAVEFORM_SINE);
		voices2[i]->begin(.9, 440, WAVEFORM_SINE);
	}

	delayFilter.frequency(3000);
	delayFilter.resonance(1);
	delay1.delay(0, 0);
	mainOutMixer.gain(0, .5);

	//LFO
	lfoVoice.amplitude(0.1);
	lfoVoice.begin(1, 3, WAVEFORM_SINE);
	lfoFilter.begin(1, 3, WAVEFORM_SINE);

	pinMode(MUX_S0_PIN, OUTPUT);
	pinMode(MUX_S1_PIN, OUTPUT);
	pinMode(MUX_S2_PIN, OUTPUT);
	pinMode(MUX_S3_PIN, OUTPUT);

	pinMode(DIGITAL_MUX_IN_PIN, INPUT_PULLUP);

	pinMode(ANALOG_MUX_0_IN_PIN, INPUT);
	pinMode(ANALOG_MUX_1_IN_PIN, INPUT);

	FastLED.addLeds<WS2811, KEY_LEDS_PIN>(leds, NUM_LEDS);

	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		SetKeyLight(i, CHSV(random(0, 255), 255, 255));
		FastLED.show();
		delay(100);
	}

	//sound startup
	voiceenv1.amplitude(0.5, 1);
	voicea1.frequency(notes[0] * 8);
	delay(100);
	voiceenv1.amplitude(0);
}

uint32_t timer = 0;
uint32_t interval = 5000;
void loop() {
	GetAnalogValues();
	ApplyKnobs();

	GetButtons();

	SetVoiceFrequencies();
	HandleButtons();
	SetBalance();
	ShowLeds();
	SaveValues();

	//if (millis() - timer > interval)
	//{
	//	timer = millis();
	//	Serial.printf("Max proc %d\n", (int)AudioProcessorUsageMax());
	//	Serial.printf("Max mem %u\n", AudioMemoryUsageMax());
	//}
}

#define AnalogChangeThreshold 2
bool IsDifferentAnalog(int index)
{
	return abs(AnalogValues[index] - LastAnalogValues[index]) > AnalogChangeThreshold;
}

void SetBalance()
{
	//balance
	if (IsDifferentAnalog(balance))
	{
		ampRight.gain(AnalogValues[balance] / 1023);
		ampLeft.gain(1 - (AnalogValues[balance] / 1023));
		LastAnalogValues[balance] = AnalogValues[balance];
	}
}

void ApplyKnobs()
{
	//volume
	float vol = (float)analogRead(VOLUME_PIN) / 1023;
	sgtl5000_1.volume(vol);
	sgtl5000_1.lineOutLevel(vol);

	//Serial.println(vol);

	//voice mix
	if (IsDifferentAnalog(voice_mix))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceMixs[i]->gain(0, AnalogValues[voice_mix] / 1023);
			voiceMixs[i]->gain(1, 1 - (AnalogValues[voice_mix] / 1023));
		}
		LastAnalogValues[voice_mix] = AnalogValues[voice_mix];
	}

	//voice wave shape
	if (DigitalValues[voice_1_waveform] != LastDigitalValues[voice_1_waveform])
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voices1[i]->begin(DigitalValues[voice_1_waveform]);
		}
		Serial.print("Voice 1 ");
		PrintWaveform(DigitalValues[voice_1_waveform]);
		LastDigitalValues[voice_1_waveform] = DigitalValues[voice_1_waveform];
	}
	if (DigitalValues[voice_2_waveform] != LastDigitalValues[voice_2_waveform])
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voices2[i]->begin(DigitalValues[voice_2_waveform]);
		}
		Serial.print("Voice 2 ");
		PrintWaveform(DigitalValues[voice_2_waveform]);
		LastDigitalValues[voice_2_waveform] = DigitalValues[voice_2_waveform];
	}

	//voice lfo waveform
	if (DigitalValues[voice_lfo_waveform] != LastDigitalValues[voice_lfo_waveform])
	{
		lfoVoice.begin(DigitalValues[voice_lfo_waveform]);
		LastDigitalValues[voice_lfo_waveform] = DigitalValues[voice_lfo_waveform];
	}

	//lfo amplitude
	if (IsDifferentAnalog(voice_lfo_strength))
	{
		lfoVoice.amplitude(mapfloat(AnalogValues[voice_lfo_strength], 0, 1023, 0, 1));
		LastAnalogValues[voice_lfo_strength] = AnalogValues[voice_lfo_strength];
	}

	//lfo freq
	if (IsDifferentAnalog(voice_lfo_frequency))
	{
		lfoVoice.frequency(AnalogValues[voice_lfo_frequency] / 8);
		LastAnalogValues[voice_lfo_frequency] = AnalogValues[voice_lfo_frequency];
	}

	//filter lfo waveform
	if (DigitalValues[filter_lfo_waveform] != LastDigitalValues[filter_lfo_waveform])
	{
		lfoFilter.begin(DigitalValues[filter_lfo_waveform]);
		LastDigitalValues[filter_lfo_waveform] = DigitalValues[filter_lfo_waveform];
	}

	//filter lfo freq
	if (IsDifferentAnalog(filter_lfo))
	{
		lfoFilter.frequency(AnalogValues[filter_lfo] / 50);
		LastAnalogValues[filter_lfo] = AnalogValues[filter_lfo];
	}

	//lfo strength
	if (IsDifferentAnalog(filter_lfo_strength))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceFilterModmixers[i]->gain(1, AnalogValues[filter_lfo_strength] / 1023);
		}
		LastAnalogValues[filter_lfo_strength] = AnalogValues[filter_lfo_strength];
	}

	//noise
	if (IsDifferentAnalog(noiseip))
	{
		noise.amplitude(AnalogValues[noiseip] / 3096);
		LastAnalogValues[noiseip] = AnalogValues[noiseip];
	}

	//filter cutoff
	if (IsDifferentAnalog(filter_cutoff))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceFilters[i]->frequency(AnalogValues[filter_cutoff] * 10);
		}
		LastAnalogValues[filter_cutoff] = AnalogValues[filter_cutoff];
	}

	//filter resonance
	if (IsDifferentAnalog(filter_resonance))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			float res = mapfloat(AnalogValues[filter_resonance], 0, 1023, .7, 5);
			voiceFilters[i]->resonance(res);
		}
		LastAnalogValues[filter_resonance] = AnalogValues[filter_resonance];
	}

	//envelope mix
	if (IsDifferentAnalog(filter_mix))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceFilterModmixers[i]->gain(0, AnalogValues[filter_mix] / 1023);
		}
		LastAnalogValues[filter_mix] = AnalogValues[filter_mix];
	}

	//delay
	if (IsDifferentAnalog(delay_time))
	{
		delay1.delay(0, AnalogValues[delay_time] / 2.4);
		LastAnalogValues[delay_time] = AnalogValues[delay_time];
	}
	//feedback
	if (IsDifferentAnalog(delay_feedback))
	{
		mainOutMixer.gain(3, AnalogValues[delay_feedback] / 1023);
		LastAnalogValues[delay_feedback] = AnalogValues[delay_feedback];
	}

	//pulse width
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		voices1[i]->pulseWidth((1 - (AnalogValues[voice_1_pulse_width] / 1023)));
	}

	if (DigitalValues[voice_2_waveform] == WAVEFORM_PULSE)
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			//voices2[i]->pulseWidth((1 - (AnalogValues[voice_2_pulse_width] / 1023)) + lfoPeak / 2);
		}
	}
}

int GetFreeVoice()
{
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		if (!IsVoiceAllocated[i])
		{
			IsVoiceAllocated[i] = true;
			return i;
		}
	}

	return -1;
}

void HandleButtons()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		if (ButtonState[i] && !LastButtonState[i])
		{
			Serial.printf("Button %u pressed: Current voice %u\n", i, ButtonVoiceAllocation[i]);

			//allocate a voice to this button if not already allocated
			if (ButtonVoiceAllocation[i] == -1)
			{
				ButtonVoiceAllocation[i] = GetFreeVoice();
				Serial.printf("Allocated %u\n", ButtonVoiceAllocation[i]);
			}
			//if we could allocate - play the note
			if (ButtonVoiceAllocation[i] != -1)
			{
				envelopes[ButtonVoiceAllocation[i]]->amplitude(1, AnalogValues[attackTime]);
				filters[ButtonVoiceAllocation[i]]->amplitude(1, AnalogValues[attackTimeFilter]);
				attackWait[ButtonVoiceAllocation[i]] = millis();
				noteTrigFlag[ButtonVoiceAllocation[i]] = true;

				uint32_t noteFinishTime = max(AnalogValues[attackTime] + AnalogValues[releaseTime] + AnalogValues[sustainLevel] + AnalogValues[decayTime], AnalogValues[attackTimeFilter] + AnalogValues[releaseTimeFilter] + AnalogValues[sustainLevelFilter] + AnalogValues[decayTimeFilter]);
				releaseWait[ButtonVoiceAllocation[i]] = millis() + noteFinishTime;
			}
		}
		else if (!ButtonState[i] && ButtonVoiceAllocation[i] != -1)
		{
			noteTrigFlag[ButtonVoiceAllocation[i]] = false;
			envelopes[ButtonVoiceAllocation[i]]->amplitude(0, AnalogValues[releaseTime]);
			filters[ButtonVoiceAllocation[i]]->amplitude(-1, AnalogValues[releaseTimeFilter]);

			//has the note finished
			if (millis() > releaseWait[ButtonVoiceAllocation[i]])
			{
				Serial.printf("Button %u note %u finshed\n", i, ButtonVoiceAllocation[i]);
				IsVoiceAllocated[ButtonVoiceAllocation[i]] = false;
				ButtonVoiceAllocation[i] = -1;
			}
		}
		if (ButtonState[i] && ButtonVoiceAllocation[i] != -1)
		{
			if (millis() - attackWait[ButtonVoiceAllocation[i]] > AnalogValues[attackTime] && noteTrigFlag[ButtonVoiceAllocation[i]]) {
				envelopes[ButtonVoiceAllocation[i]]->amplitude(AnalogValues[sustainLevel], AnalogValues[decayTime]);
			}
			if (millis() - attackWait[ButtonVoiceAllocation[i]] > AnalogValues[attackTimeFilter] && noteTrigFlag[ButtonVoiceAllocation[i]]) {
				filters[ButtonVoiceAllocation[i]]->amplitude(AnalogValues[sustainLevelFilter], AnalogValues[decayTimeFilter]);
			}
		}
	}
}

float GetValueWithDeadband(int address, float min, float max, float mid)
{
	float val = AnalogValues[address];

	if (val < 400)
	{
		float newf = mapfloat(val, 0, 399, min, mid);
		return newf;
	}
	if (AnalogValues[address] > 600)
	{
		float newf = mapfloat(val, 601, 1023, mid, max);
		return newf;
	}
	else
	{
		return mid;
	}
}

float DetuneFrequency(float f)
{
	return mapfloat(AnalogValues[voice_2_detune], 0, 1023, .875, 1.125) * f;
	//return GetValueWithDeadband(voice_2_detune, .875, 1.125, 1) * f;
}

void SetVoiceFrequencies()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		if (ButtonVoiceAllocation[i] != -1)
		{
			voices1[ButtonVoiceAllocation[i]]->frequency(notes[i] * DigitalValues[voice_1_octave]);
			voices2[ButtonVoiceAllocation[i]]->frequency(DetuneFrequency(notes[i] * DigitalValues[voice_2_octave]));
		}
	}
}

void SaveValues()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		LastButtonState[i] = ButtonState[i];
	}
}

void ShowLeds()
{
	for (int i = 0; i < NUM_LEDS; i++)
	{
		if (ButtonVoiceAllocation[i] != -1)
		{
			SetKeyLight(i, CHSV(255, 255, 255));
		}
		else
		{
			SetKeyLight(i, CRGB::Black);
		}
	}

	FastLED.show();
}

int GetOctave(float val)
{
	return MapSwitch(val, 11) + 1;
}

int GetVoiceWaveForm(float val)
{
	int index = MapSwitch(val, 3);
	return WaveForms[index];
}

int GetLFOWaveForm(float val)
{
	int index = MapSwitch(val, 4);
	return WaveForms[index];
}

long MapSwitch(long in, long outMax)
{
	long halfstripe = (1023 / outMax) / 2;
	return ((in + halfstripe) * outMax) / 1023;
}

void GetButtons()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		ButtonState[i] = GetKeyInput(i);
	}
}