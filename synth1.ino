#include <FastLED.h>
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
//#include <SD.h>
//#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioSynthWaveformDc     lfoenvelope;    //xy=970.5,1478.5
AudioSynthWaveform       lfoVoice; //xy=993,1526
AudioSynthNoiseWhite     voicen1;        //xy=1103.7500190734863,1963.2500400543213
AudioSynthWaveform       lfoFilter;            //xy=1116.5,1718.5
AudioAnalyzePeak         peakLfoFilter;          //xy=1146,1646
AudioMixer4              mixer1;         //xy=1173.25,1505.5
AudioAnalyzePeak         peak1;          //xy=1298.5,1486
AudioSynthWaveform       voiceb8; //xy=1766.25,2527.5
AudioSynthWaveform       voicea8; //xy=1771.25,2484.5
AudioSynthWaveform       voiceb7; //xy=1785,2223.75
AudioSynthWaveform       voicea7; //xy=1790,2180.75
AudioSynthWaveform       voiceb5;        //xy=1795.5,1604
AudioSynthWaveform       voiceb6; //xy=1796.25,1910
AudioSynthWaveform       voicea5;        //xy=1800.5,1561
AudioSynthWaveform       voiceb4;        //xy=1801.5,1320
AudioSynthWaveform       voicea6; //xy=1801.25,1867
AudioSynthWaveform       voicea4;        //xy=1806.5,1277
AudioSynthWaveform       voiceb2;        //xy=1811.5,792
AudioSynthWaveform       voiceb1;        //xy=1814.5,503
AudioSynthWaveform       voicea2;        //xy=1816.5,749
AudioSynthWaveform       voicea1;        //xy=1819.5,460
AudioSynthWaveform       voiceb3;        //xy=1819.5,1075
AudioSynthWaveform       voicea3;        //xy=1824.5,1032
AudioSynthWaveformDc     voicefilterenv8; //xy=1889.25,2677.5
AudioSynthWaveformDc     voicefilterenv7; //xy=1908,2373.75
AudioMixer4              voicemix8; //xy=1911.25,2547.5
AudioSynthWaveformDc     voiceenv8; //xy=1912.25,2612.5
AudioSynthWaveformDc     voicefilterenv5; //xy=1918.5,1754
AudioSynthWaveformDc     voicefilterenv6; //xy=1919.25,2060
AudioSynthWaveformDc     voicefilterenv4; //xy=1924.5,1470
AudioSynthWaveformDc     voicefilterenv2; //xy=1934.5,941
AudioMixer4              voicemix7;  //xy=1930,2243.75
AudioSynthWaveformDc     voicefilterenv1; //xy=1936.5,652
AudioSynthWaveformDc     voiceenv7; //xy=1931,2308.75
AudioSynthWaveformDc     voicefilterenv3; //xy=1941.5,1225
AudioMixer4              voicemix5;      //xy=1940.5,1624
AudioSynthWaveformDc     voiceenv5;      //xy=1941.5,1689
AudioMixer4              voicemix6; //xy=1941.25,1930
AudioSynthWaveformDc     voiceenv6; //xy=1942.25,1995
AudioMixer4              voicemix4;      //xy=1946.5,1340
AudioSynthWaveformDc     voiceenv4;      //xy=1947.5,1405
AudioMixer4              voicemix2;      //xy=1956.5,812
AudioSynthWaveformDc     voiceenv2;      //xy=1957.5,877
AudioMixer4              voicemix1;      //xy=1959.5,523
AudioSynthWaveformDc     voiceenv1;      //xy=1960.5,588
AudioMixer4              voicemix3;      //xy=1964.5,1095
AudioSynthWaveformDc     voiceenv3;      //xy=1965.5,1160
AudioEffectMultiply      voicemultiply8; //xy=2075.25,2570.5
AudioMixer4              voicefiltermodmixer8; //xy=2092.25,2695.5
AudioEffectMultiply      voicemultiply7; //xy=2094,2266.75
AudioEffectMultiply      voicemultiply5; //xy=2104.5,1647
AudioEffectMultiply      voicemultiply6; //xy=2105.25,1953
AudioEffectMultiply      voicemultiply4; //xy=2110.5,1363
AudioMixer4              voicefiltermodmixer7; //xy=2111,2391.75
AudioEffectMultiply      voicemultiply2; //xy=2120.5,835
AudioEffectMultiply      voicemultiply1; //xy=2123.5,546
AudioMixer4              voicefiltermodmixer5; //xy=2121.5,1772
AudioMixer4              voicefiltermodmixer6; //xy=2122.25,2078
AudioEffectMultiply      voicemultiply3; //xy=2128.5,1118
AudioMixer4              voicefiltermodmixer4; //xy=2127.5,1488
AudioMixer4              voicefiltermodmixer2; //xy=2137.5,960
AudioMixer4              voicefiltermodmixer1; //xy=2140.5,671
AudioMixer4              voicefiltermodmixer3; //xy=2145.5,1243
AudioFilterStateVariable voicefilter8; //xy=2278.25,2637.5
AudioFilterStateVariable voicefilter7; //xy=2297,2333.75
AudioFilterStateVariable voicefilter5;   //xy=2307.5,1714
AudioFilterStateVariable voicefilter6; //xy=2308.25,2020
AudioFilterStateVariable voicefilter4;   //xy=2313.5,1430
AudioFilterStateVariable voicefilter2;   //xy=2323.5,902
AudioFilterStateVariable voicefilter1;   //xy=2326.5,613
AudioFilterStateVariable voicefilter3;   //xy=2331.5,1185
AudioMixer4              last4premix1;   //xy=2728.5,1819
AudioMixer4              last4premix;    //xy=2730.5,1736
AudioMixer4              first4premix;   //xy=2731.5,1652
AudioMixer4              last4premix2;   //xy=3020.5,1734
AudioEffectDelay         delay1;         //xy=3225.5,2189
AudioMixer4              mainOutMixer;   //xy=3251.5,1729
AudioFilterStateVariable delayFilter;    //xy=3413.5,2150
AudioAmplifier           ampLeft;           //xy=3549,1652
AudioAmplifier           ampRight;           //xy=3549,1703
AudioOutputI2S           i2s1;           //xy=3724.5,1678
AudioConnection          patchCord1(lfoenvelope, 0, mixer1, 0);
AudioConnection          patchCord2(lfoVoice, 0, mixer1, 1);
AudioConnection          patchCord3(voicen1, 0, voicemix1, 2);
AudioConnection          patchCord4(voicen1, 0, voicemix2, 2);
AudioConnection          patchCord5(voicen1, 0, voicemix3, 2);
AudioConnection          patchCord6(voicen1, 0, voicemix4, 2);
AudioConnection          patchCord7(voicen1, 0, voicemix5, 2);
AudioConnection          patchCord8(voicen1, 0, voicemix6, 2);
AudioConnection          patchCord9(voicen1, 0, voicemix7, 2);
AudioConnection          patchCord10(voicen1, 0, voicemix8, 2);
AudioConnection          patchCord11(lfoFilter, 0, voicefiltermodmixer1, 1);
AudioConnection          patchCord12(lfoFilter, 0, voicefiltermodmixer2, 1);
AudioConnection          patchCord13(lfoFilter, 0, voicefiltermodmixer3, 1);
AudioConnection          patchCord14(lfoFilter, 0, voicefiltermodmixer4, 1);
AudioConnection          patchCord15(lfoFilter, 0, voicefiltermodmixer5, 1);
AudioConnection          patchCord16(lfoFilter, 0, voicefiltermodmixer6, 1);
AudioConnection          patchCord17(lfoFilter, 0, voicefiltermodmixer7, 1);
AudioConnection          patchCord18(lfoFilter, 0, voicefiltermodmixer8, 1);
AudioConnection          patchCord19(lfoFilter, peakLfoFilter);
AudioConnection          patchCord20(mixer1, peak1);
AudioConnection          patchCord21(voiceb8, 0, voicemix8, 1);
AudioConnection          patchCord22(voicea8, 0, voicemix8, 0);
AudioConnection          patchCord23(voiceb7, 0, voicemix7, 1);
AudioConnection          patchCord24(voicea7, 0, voicemix7, 0);
AudioConnection          patchCord25(voiceb5, 0, voicemix5, 1);
AudioConnection          patchCord26(voiceb6, 0, voicemix6, 1);
AudioConnection          patchCord27(voicea5, 0, voicemix5, 0);
AudioConnection          patchCord28(voiceb4, 0, voicemix4, 1);
AudioConnection          patchCord29(voicea6, 0, voicemix6, 0);
AudioConnection          patchCord30(voicea4, 0, voicemix4, 0);
AudioConnection          patchCord31(voiceb2, 0, voicemix2, 1);
AudioConnection          patchCord32(voiceb1, 0, voicemix1, 1);
AudioConnection          patchCord33(voicea2, 0, voicemix2, 0);
AudioConnection          patchCord34(voicea1, 0, voicemix1, 0);
AudioConnection          patchCord35(voiceb3, 0, voicemix3, 1);
AudioConnection          patchCord36(voicea3, 0, voicemix3, 0);
AudioConnection          patchCord37(voicefilterenv8, 0, voicefiltermodmixer8, 0);
AudioConnection          patchCord38(voicefilterenv7, 0, voicefiltermodmixer7, 0);
AudioConnection          patchCord39(voicemix8, 0, voicemultiply8, 0);
AudioConnection          patchCord40(voiceenv8, 0, voicemultiply8, 1);
AudioConnection          patchCord41(voicefilterenv5, 0, voicefiltermodmixer5, 0);
AudioConnection          patchCord42(voicefilterenv6, 0, voicefiltermodmixer6, 0);
AudioConnection          patchCord43(voicefilterenv4, 0, voicefiltermodmixer4, 0);
AudioConnection          patchCord44(voicefilterenv2, 0, voicefiltermodmixer2, 0);
AudioConnection          patchCord45(voicemix7, 0, voicemultiply7, 0);
AudioConnection          patchCord46(voicefilterenv1, 0, voicefiltermodmixer1, 0);
AudioConnection          patchCord47(voiceenv7, 0, voicemultiply7, 1);
AudioConnection          patchCord48(voicefilterenv3, 0, voicefiltermodmixer3, 0);
AudioConnection          patchCord49(voicemix5, 0, voicemultiply5, 0);
AudioConnection          patchCord50(voiceenv5, 0, voicemultiply5, 1);
AudioConnection          patchCord51(voicemix6, 0, voicemultiply6, 0);
AudioConnection          patchCord52(voiceenv6, 0, voicemultiply6, 1);
AudioConnection          patchCord53(voicemix4, 0, voicemultiply4, 0);
AudioConnection          patchCord54(voiceenv4, 0, voicemultiply4, 1);
AudioConnection          patchCord55(voicemix2, 0, voicemultiply2, 0);
AudioConnection          patchCord56(voiceenv2, 0, voicemultiply2, 1);
AudioConnection          patchCord57(voicemix1, 0, voicemultiply1, 0);
AudioConnection          patchCord58(voiceenv1, 0, voicemultiply1, 1);
AudioConnection          patchCord59(voicemix3, 0, voicemultiply3, 0);
AudioConnection          patchCord60(voiceenv3, 0, voicemultiply3, 1);
AudioConnection          patchCord61(voicemultiply8, 0, voicefilter8, 0);
AudioConnection          patchCord62(voicefiltermodmixer8, 0, voicefilter8, 1);
AudioConnection          patchCord63(voicemultiply7, 0, voicefilter7, 0);
AudioConnection          patchCord64(voicemultiply5, 0, voicefilter5, 0);
AudioConnection          patchCord65(voicemultiply6, 0, voicefilter6, 0);
AudioConnection          patchCord66(voicemultiply4, 0, voicefilter4, 0);
AudioConnection          patchCord67(voicefiltermodmixer7, 0, voicefilter7, 1);
AudioConnection          patchCord68(voicemultiply2, 0, voicefilter2, 0);
AudioConnection          patchCord69(voicemultiply1, 0, voicefilter1, 0);
AudioConnection          patchCord70(voicefiltermodmixer5, 0, voicefilter5, 1);
AudioConnection          patchCord71(voicefiltermodmixer6, 0, voicefilter6, 1);
AudioConnection          patchCord72(voicemultiply3, 0, voicefilter3, 0);
AudioConnection          patchCord73(voicefiltermodmixer4, 0, voicefilter4, 1);
AudioConnection          patchCord74(voicefiltermodmixer2, 0, voicefilter2, 1);
AudioConnection          patchCord75(voicefiltermodmixer1, 0, voicefilter1, 1);
AudioConnection          patchCord76(voicefiltermodmixer3, 0, voicefilter3, 1);
AudioConnection          patchCord77(voicefilter8, 0, last4premix, 3);
AudioConnection          patchCord78(voicefilter7, 0, last4premix, 2);
AudioConnection          patchCord79(voicefilter5, 0, last4premix, 0);
AudioConnection          patchCord80(voicefilter6, 0, last4premix, 1);
AudioConnection          patchCord81(voicefilter4, 0, first4premix, 3);
AudioConnection          patchCord82(voicefilter2, 0, first4premix, 1);
AudioConnection          patchCord83(voicefilter1, 0, first4premix, 0);
AudioConnection          patchCord84(voicefilter3, 0, first4premix, 2);
AudioConnection          patchCord85(last4premix1, 0, last4premix2, 2);
AudioConnection          patchCord86(last4premix, 0, last4premix2, 1);
AudioConnection          patchCord87(first4premix, 0, last4premix2, 0);
AudioConnection          patchCord88(last4premix2, 0, mainOutMixer, 2);
AudioConnection          patchCord89(delay1, 0, delayFilter, 0);
AudioConnection          patchCord90(mainOutMixer, delay1);
AudioConnection          patchCord91(mainOutMixer, ampRight);
AudioConnection          patchCord92(mainOutMixer, ampLeft);
AudioConnection          patchCord93(delayFilter, 0, mainOutMixer, 3);
AudioConnection          patchCord94(ampLeft, 0, i2s1, 0);
AudioConnection          patchCord95(ampRight, 0, i2s1, 1);
AudioControlSGTL5000     sgtl5000_1;     //xy=3214.5,1496
										 // GUItool: end automatically generated code

#define NUM_LEDS 13
#define NUM_BUTTONS 13
#define NUM_VOICES 8
#define VERSION 4

//PINS
#define KEY_LEDS_PIN 17
#define DIGITAL_SPARE_PIN_0 5
#define DIGITAL_SPARE_PIN_1 8
#define ANALOG_SPARE_PIN_0 16

#define MUX_S0_PIN 4
#define MUX_S1_PIN 3
#define MUX_S2_PIN 2
#define MUX_S3_PIN 1

#define DIGITAL_MUX_IN_PIN 16
#define ANALOG_MUX_0_IN_PIN 21
#define ANALOG_MUX_1_IN_PIN 20

#define VOLUME_PIN 15

//ANALOG MUX addresses
#define VOICE_1_WAVEFORM 1, 15
#define VOICE_1_PULSE_WIDTH 1, 14
#define VOICE_1_OCTAVE 1, 13
#define VOICE_2_WAVEFORM 1, 12
#define VOICE_2_PULSE_WIDTH 1, 11
#define VOICE_2_OCTAVE 1, 10
#define VOICE_2_DETUNE 1, 9
#define VOICE_MIX 1, 8
#define VOICE_LFO 1, 7
#define VOICE_LFO_WAVEFORM 1, 6
#define VOICE_LFO_STRENGTH 1, 5
#define ENVELOPE_1 1, 4
#define ENVELOPE_2 1, 3
#define ENVELOPE_3 1, 2
#define ENVELOPE_4 1, 1
#define BALANCE 1, 0
#define FILTER_CUTOFF 0, 15
#define FILTER_RESONANCE 0, 14
#define FILTER_1 0, 13
#define FILTER_2 0, 12
#define FILTER_3 0, 11
#define FILTER_4 0, 10
#define FILTER_MIX 0, 9
#define FILTER_LFO 0, 8
#define FILTER_LFO_WAVEFORM 0, 7
#define FILTER_LFO_STRENGTH 0, 6
#define DELAY_TIME 0, 5
#define DELAY_FEEDBACK 0, 4
#define NOISE 0, 3
#define SPARE0 0, 2
#define SPARE1 0, 1
#define SPARE2 0, 0

#define NUM_DIGITAL_VALUES 6
short DigitalValues[NUM_DIGITAL_VALUES];
short LastDigitalValues[6];
#define voice_1_waveform 0
#define voice_1_octave 1
#define voice_2_waveform 2
#define voice_2_octave 3
#define voice_lfo_waveform 4
#define filter_lfo_waveform 5

#define NUM_ANALOG_VALUES 26
float AnalogValues[NUM_ANALOG_VALUES];
float LastAnalogValues[NUM_ANALOG_VALUES];
#define voice_1_pulse_width 0
#define voice_2_pulse_width 1
#define voice_2_detune 2
#define voice_mix 3
#define voice_lfo 4
#define voice_lfo_strength 5

#define attackTime 6
#define sustainLevel 7
#define decayTime 8
#define releaseTime 9

#define balance 10
#define filter_cutoff 11
#define filter_resonance 12

#define attackTimeFilter 13
#define sustainLevelFilter 14
#define decayTimeFilter 15
#define releaseTimeFilter 16

#define filter_mix 17
#define filter_lfo 18
#define filter_lfo_strength 19
#define delay_time 20
#define delay_feedback 21
#define noise 22
#define spare0 23
#define spare1 24
#define spare2 25

float notes[] = { 32.70320 , 34.64783 , 36.70810 , 38.89087, 41.20344, 43.65353, 46.24930, 48.99943, 51.91309, 55.00000, 58.27047, 61.73541, 65.40639 };

float lfoPeak = 1;
float lfoModulation = 1;

short WaveForms[5] = {
	WAVEFORM_SINE,
	WAVEFORM_SAWTOOTH,
	WAVEFORM_SAWTOOTH_REVERSE,
	WAVEFORM_PULSE,
	WAVEFORM_SAMPLE_HOLD,
};

void  PrintWaveform(short index)
{
	switch (index)
	{
	case WAVEFORM_SINE:
	{
		Serial.println("WAVEFORM_SINE");
		break;
	}
	case WAVEFORM_SAWTOOTH:
	{
		Serial.println("WAVEFORM_SAWTOOTH");
		break;
	}
	case WAVEFORM_SAWTOOTH_REVERSE:
	{
		Serial.println("WAVEFORM_SAWTOOTH_REVERSE");
		break;
	}
	case WAVEFORM_PULSE:
	{
		Serial.println("WAVEFORM_PULSE");
		break;
	}
	case WAVEFORM_SAMPLE_HOLD:
	{
		Serial.println("WAVEFORM_SAMPLE_HOLD");
		break;
	}
	}
}

float GetAnalogValue(int mux, int address)
{
	digitalWrite(MUX_S0_PIN, bitRead(address, 0));
	digitalWrite(MUX_S1_PIN, bitRead(address, 1));
	digitalWrite(MUX_S2_PIN, bitRead(address, 2));
	digitalWrite(MUX_S3_PIN, bitRead(address, 3));

	int muxPin = ANALOG_MUX_1_IN_PIN;
	if (mux == 0)
	{
		muxPin = ANALOG_MUX_0_IN_PIN;
	}

	float sum = 0;
	for (size_t i = 0; i < 20; i++)
	{
		sum += analogRead(muxPin);
	}
	return sum / 20;
}

CRGB leds[NUM_LEDS];

int keyLightMap[] = { 12, 0, 11, 1, 10, 9, 2, 8, 3, 7, 4, 6, 5 };

void SetKeyLight(int key, CRGB colour)
{
	leds[keyLightMap[key]] = colour;
}

bool GetKeyInput(int address)
{
	if (address < 16)
	{
		digitalWrite(MUX_S0_PIN, bitRead(address, 0));
		digitalWrite(MUX_S1_PIN, bitRead(address, 1));
		digitalWrite(MUX_S2_PIN, bitRead(address, 2));
		digitalWrite(MUX_S3_PIN, bitRead(address, 3));

		return analogRead(DIGITAL_MUX_IN_PIN) < 900;
	}
	else
	{
		Serial.println("Error GetDigitalInput() parameter out of range");
	}

	return false;
}

float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void GetAnalogValues()
{
	DigitalValues[voice_1_waveform] = GetVoiceWaveForm(GetAnalogValue(VOICE_1_WAVEFORM));
	AnalogValues[voice_1_pulse_width] = GetAnalogValue(VOICE_1_PULSE_WIDTH);
	DigitalValues[voice_1_octave] = GetOctave(GetAnalogValue(VOICE_1_OCTAVE));
	DigitalValues[voice_2_waveform] = GetVoiceWaveForm(GetAnalogValue(VOICE_2_WAVEFORM));
	AnalogValues[voice_2_pulse_width] = GetAnalogValue(VOICE_2_PULSE_WIDTH);
	DigitalValues[voice_2_octave] = GetOctave(GetAnalogValue(VOICE_2_OCTAVE));
	AnalogValues[voice_2_detune] = GetAnalogValue(VOICE_2_DETUNE);
	AnalogValues[voice_mix] = GetAnalogValue(VOICE_MIX);
	AnalogValues[voice_lfo] = GetAnalogValue(VOICE_LFO);
	DigitalValues[voice_lfo_waveform] = GetLFOWaveForm(GetAnalogValue(VOICE_LFO_WAVEFORM));
	AnalogValues[voice_lfo_strength] = GetAnalogValue(VOICE_LFO_STRENGTH);
	AnalogValues[attackTime] = GetAnalogValue(ENVELOPE_1) * 2;
	AnalogValues[attackTimeFilter] = GetAnalogValue(FILTER_1) * 2;

	AnalogValues[sustainLevel] = GetAnalogValue(ENVELOPE_2) / 1023;
	AnalogValues[sustainLevelFilter] = mapfloat(GetAnalogValue(FILTER_2), 0, 1023, -1, 1);

	AnalogValues[decayTime] = GetAnalogValue(ENVELOPE_3);
	AnalogValues[decayTimeFilter] = GetAnalogValue(FILTER_3);

	AnalogValues[releaseTime] = GetAnalogValue(ENVELOPE_4) * 2;
	AnalogValues[releaseTimeFilter] = GetAnalogValue(FILTER_4) * 2;

	AnalogValues[balance] = GetAnalogValue(BALANCE);
	AnalogValues[filter_cutoff] = GetAnalogValue(FILTER_CUTOFF);
	AnalogValues[filter_resonance] = GetAnalogValue(FILTER_RESONANCE);
	AnalogValues[filter_mix] = GetAnalogValue(FILTER_MIX);
	AnalogValues[filter_lfo] = GetAnalogValue(FILTER_LFO);
	DigitalValues[filter_lfo_waveform] = GetLFOWaveForm(GetAnalogValue(FILTER_LFO_WAVEFORM));
	AnalogValues[filter_lfo_strength] = GetAnalogValue(FILTER_LFO_STRENGTH);
	AnalogValues[delay_time] = GetAnalogValue(DELAY_TIME);
	AnalogValues[delay_feedback] = GetAnalogValue(DELAY_FEEDBACK);
	AnalogValues[noise] = GetAnalogValue(NOISE);
	//GetAnalogValue(SPARE0);v
	//GetAnalogValue(SPARE1);
	//GetAnalogValue(SPARE2);
}

//void PrintValues()
//{
//	Serial.println();
//	Serial.println();
//	Serial.println();
//	Serial.println();
//	Serial.println("Values");
//	Serial.println("=========================");
//
//	Serial.print("voice_1_waveform ");
//	PrintWaveform(voice_1_waveform);
//	Serial.println(voice_1_pulse_width);
//	Serial.print("voice_1_octave "); Serial.println(voice_1_octave);
//	Serial.print("voice_2_waveform "); PrintWaveform(voice_2_waveform);
//	Serial.println(voice_2_pulse_width);
//	Serial.print("voice_2_octave "); Serial.println(voice_2_octave);
//	Serial.println(voice_2_detune);
//	Serial.println(voice_mix);
//	Serial.println(voice_lfo);
//	Serial.print("voice_lfo_waveform "); PrintWaveform(voice_lfo_waveform);
//	Serial.println(voice_lfo_strength);
//	Serial.println(attackTime);
//	Serial.println(sustainLevel);
//	Serial.println(decayTime);
//	Serial.println(releaseTime);
//	Serial.println(envelope_mix);
//	Serial.println(filter_cutoff);
//	Serial.println(filter_resonance);
//	Serial.println(attackTimeFilter);
//	Serial.println(sustainLevelFilter);
//	Serial.println(decayTimeFilter);
//	Serial.println(releaseTimeFilter);
//	Serial.println(filter_mix);
//	Serial.println(filter_lfo);
//	Serial.print("filter_lfo_waveform "); PrintWaveform(filter_lfo_waveform);
//	Serial.println(filter_lfo_strength);
//	Serial.println(delay_time);
//	Serial.println(delay_feedback);
//	Serial.println(noise);
//	//Serial.println(spare0);
//	//Serial.println(spare1);
//	//Serial.println(spare2);
//}

uint32_t attackWait[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
uint32_t releaseWait[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
bool noteTrigFlag[] = { false, false, false, false, false, false, false, false, false, false, false, false, false };
bool ButtonState[] = { false, false, false, false, false, false, false, false, false, false, false, false, false };
bool LastButtonState[] = { false, false, false, false, false, false, false, false, false, false, false, false, false };

AudioSynthWaveform* voices1[] = { &voicea1, &voicea2,&voicea3,&voicea4,&voicea5,&voicea6,&voicea7,&voicea8 };
AudioSynthWaveform* voices2[] = { &voiceb1, &voiceb2, &voiceb3, &voiceb4, &voiceb5, &voiceb6, &voiceb7, &voiceb8 };
AudioSynthWaveformDc* filters[] = { &voicefilterenv1, &voicefilterenv2, &voicefilterenv4, &voicefilterenv4, &voicefilterenv5, &voicefilterenv6, &voicefilterenv7, &voicefilterenv8 };
AudioSynthWaveformDc* envelopes[] = { &voiceenv1,&voiceenv2,&voiceenv3,&voiceenv4,&voiceenv5,&voiceenv6,&voiceenv7,&voiceenv8 };
AudioMixer4* voiceMixs[] = { &voicemix1, &voicemix2, &voicemix3, &voicemix4, &voicemix5, &voicemix6, &voicemix7, &voicemix8 };
AudioFilterStateVariable* voiceFilters[] = { &voicefilter1,&voicefilter2,&voicefilter3,&voicefilter4,&voicefilter5,&voicefilter6,&voicefilter7,&voicefilter8 };
AudioMixer4* voiceFilterModmixers[] = { &voicefiltermodmixer1, &voicefiltermodmixer2, &voicefiltermodmixer3, &voicefiltermodmixer4, &voicefiltermodmixer5, &voicefiltermodmixer6, &voicefiltermodmixer7, &voicefiltermodmixer8 };

bool IsVoiceAllocated[NUM_VOICES];
int ButtonVoiceAllocation[NUM_BUTTONS];
#define memblock 160

void setup() {
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		ButtonVoiceAllocation[i] = -1;
	}
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		IsVoiceAllocated[i] = false;
	}

	Serial.begin(115200); // use the serial port
	Serial.print("Version ");
	Serial.println(VERSION);

	for (size_t i = 0; i < NUM_ANALOG_VALUES; i++)
	{
		LastAnalogValues[i] = -100;
	}
	for (size_t i = 0; i < NUM_DIGITAL_VALUES; i++)
	{
		LastDigitalValues[i] = -100;
	}
	static DMAMEM audio_block_t data[memblock];
	AudioStream::initialize_memory(data, memblock);

	sgtl5000_1.enable();
	sgtl5000_1.volume(.8);

	//key mixers
	first4premix.gain(0, .25);
	first4premix.gain(1, .25);
	first4premix.gain(2, .25);
	first4premix.gain(3, .25);

	last4premix.gain(0, .25);
	last4premix.gain(1, .25);
	last4premix.gain(2, .25);
	last4premix.gain(3, .25);

	last4premix1.gain(0, .25);
	last4premix1.gain(1, .25);
	last4premix1.gain(2, .25);
	last4premix1.gain(3, .25);

	//mix the prepre mixers
	last4premix2.gain(0, .25);
	last4premix2.gain(1, .25);
	last4premix2.gain(2, .25);
	last4premix2.gain(3, .25);

	//init the key voices
	//Voice 1
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		voices1[i]->begin(.9, 440, WAVEFORM_SINE);
		voices2[i]->begin(.9, 440, WAVEFORM_SINE);
	}

	delayFilter.frequency(3000);
	delayFilter.resonance(1);
	delay1.delay(0, 0);
	mainOutMixer.gain(0, .5);

	//LFO
	lfoVoice.begin(1, 3, WAVEFORM_SINE);
	lfoFilter.begin(1, 3, WAVEFORM_SINE);

	lfoenvelope.amplitude(1);

	pinMode(MUX_S0_PIN, OUTPUT);
	pinMode(MUX_S1_PIN, OUTPUT);
	pinMode(MUX_S2_PIN, OUTPUT);
	pinMode(MUX_S3_PIN, OUTPUT);

	pinMode(DIGITAL_MUX_IN_PIN, INPUT_PULLUP);

	pinMode(ANALOG_MUX_0_IN_PIN, INPUT);
	pinMode(ANALOG_MUX_1_IN_PIN, INPUT);

	FastLED.addLeds<WS2811, KEY_LEDS_PIN>(leds, NUM_LEDS);

	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		SetKeyLight(i, CHSV(random(0, 255), 255, 255));
		FastLED.show();
		delay(100);
	}

	//sound startup
	voiceenv1.amplitude(0.5, 1);
	voicea1.frequency(notes[0] * 8);
	delay(100);
	voiceenv1.amplitude(0);
}

uint32_t timer = 0;
uint32_t interval = 5000;
void loop() {
	GetAnalogValues();
	ApplyKnobs();

	GetButtons();

	SetVoiceFrequencies();
	HandleButtons();
	SetBalance();
	ShowLeds();
	SaveValues();

	//if (millis() - timer > interval)
	//{
	//	timer = millis();
	//	Serial.printf("Max proc %d\n", (int)AudioProcessorUsageMax());
	//	Serial.printf("Max mem %u\n", AudioMemoryUsageMax());
	//}
}

#define AnalogChangeThreshold 20
bool IsDifferentAnalog(int index)
{
	return abs(AnalogValues[index] - LastAnalogValues[index]) > AnalogChangeThreshold;
}

void SetBalance()
{
	//balance
	if (IsDifferentAnalog(balance))
	{
		ampRight.gain(AnalogValues[balance] / 1023);
		ampLeft.gain(1 - (AnalogValues[balance] / 1023));
		LastAnalogValues[balance] = AnalogValues[balance];
	}

	//if (peakLfoFilter.available())
	//{
	//	//0..1
	//	float swing = AnalogValues[balance] / 1023;

	//	//0..0.5
	//	float left = peakLfoFilter.read() * swing;
	//	Serial.printf("swing %f left %f\n", swing, left);

	//	ampLeft.gain(left);
	//	ampRight.gain(1 - left);
	//}
}

void ApplyKnobs()
{
	//volume
	float vol = (float)analogRead(VOLUME_PIN) / 1023;
	sgtl5000_1.volume(vol);
	sgtl5000_1.lineOutLevel(vol);

	//Serial.println(vol);

	//voice mix
	if (IsDifferentAnalog(voice_mix))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceMixs[i]->gain(0, AnalogValues[voice_mix] / 1023);
			voiceMixs[i]->gain(1, 1 - (AnalogValues[voice_mix] / 1023));
		}
		LastAnalogValues[voice_mix] = AnalogValues[voice_mix];
	}

	//voice wave shape
	if (DigitalValues[voice_1_waveform] != LastDigitalValues[voice_1_waveform])
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voices1[i]->begin(DigitalValues[voice_1_waveform]);
		}
		Serial.print("Voice 1 ");
		PrintWaveform(DigitalValues[voice_1_waveform]);
		LastDigitalValues[voice_1_waveform] = DigitalValues[voice_1_waveform];
	}
	if (DigitalValues[voice_2_waveform] != LastDigitalValues[voice_2_waveform])
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voices2[i]->begin(DigitalValues[voice_2_waveform]);
		}
		Serial.print("Voice 2 ");
		PrintWaveform(DigitalValues[voice_2_waveform]);
		LastDigitalValues[voice_2_waveform] = DigitalValues[voice_2_waveform];
	}

	//voice lfo waveform
	if (DigitalValues[voice_lfo_waveform] != LastDigitalValues[voice_lfo_waveform])
	{
		lfoVoice.begin(DigitalValues[voice_lfo_waveform]);
		LastDigitalValues[voice_lfo_waveform] = DigitalValues[voice_lfo_waveform];
	}

	//lfo freq
	if (IsDifferentAnalog(voice_lfo))
	{
		lfoVoice.frequency(AnalogValues[voice_lfo] / 50);
		LastAnalogValues[voice_lfo] = AnalogValues[voice_lfo];
	}

	//filter lfo waveform
	if (DigitalValues[filter_lfo_waveform] != LastDigitalValues[filter_lfo_waveform])
	{
		lfoFilter.begin(DigitalValues[filter_lfo_waveform]);
		LastDigitalValues[filter_lfo_waveform] = DigitalValues[filter_lfo_waveform];
	}

	//filter lfo freq
	if (IsDifferentAnalog(filter_lfo))
	{
		lfoFilter.frequency(AnalogValues[filter_lfo] / 50);
		LastAnalogValues[filter_lfo] = AnalogValues[filter_lfo];
	}

	//lfo strength
	if (IsDifferentAnalog(filter_lfo_strength))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceFilterModmixers[i]->gain(1, AnalogValues[filter_lfo_strength] / 1023);
		}
		LastAnalogValues[filter_lfo_strength] = AnalogValues[filter_lfo_strength];
	}

	//noise
	if (IsDifferentAnalog(noise))
	{
		voicen1.amplitude(AnalogValues[noise] / 3096);
		LastAnalogValues[noise] = AnalogValues[noise];
	}

	//filter cutoff
	if (IsDifferentAnalog(filter_cutoff))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceFilters[i]->frequency(AnalogValues[filter_cutoff] * 10);
		}
		LastAnalogValues[filter_cutoff] = AnalogValues[filter_cutoff];
	}

	//filter resonance
	if (IsDifferentAnalog(filter_resonance))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			float res = mapfloat(AnalogValues[filter_resonance], 0, 1023, .7, 5);
			voiceFilters[i]->resonance(res);
		}
		LastAnalogValues[filter_resonance] = AnalogValues[filter_resonance];
	}

	//envelope mix
	if (IsDifferentAnalog(filter_mix))
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voiceFilterModmixers[i]->gain(0, AnalogValues[filter_mix] / 1023);
		}
		LastAnalogValues[filter_mix] = AnalogValues[filter_mix];
	}

	//delay
	if (IsDifferentAnalog(delay_time))
	{
		delay1.delay(0, AnalogValues[delay_time] / 2.4);
		LastAnalogValues[delay_time] = AnalogValues[delay_time];
	}
	//feedback
	if (IsDifferentAnalog(delay_feedback))
	{
		mainOutMixer.gain(3, AnalogValues[delay_feedback] / 1023);
		LastAnalogValues[delay_feedback] = AnalogValues[delay_feedback];
	}

	if (peak1.available())
	{
		lfoPeak = peak1.read() * (AnalogValues[voice_lfo_strength] / 1023);
	}

	//pulse width
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		voices1[i]->pulseWidth((1 - (AnalogValues[voice_1_pulse_width] / 1023)) + lfoPeak / 2);
	}

	//	lfoModulation = ((AnalogValues[voice_2_pulse_width] / 1023) * 5) * lfoPeak + 1;
	lfoModulation = (lfoPeak / 5 + 1);
	//Serial.println(lfoPeak);
	if (DigitalValues[voice_2_waveform] == WAVEFORM_PULSE)
	{
		for (size_t i = 0; i < NUM_VOICES; i++)
		{
			voices2[i]->pulseWidth((1 - (AnalogValues[voice_2_pulse_width] / 1023)) + lfoPeak / 2);
		}
	}
}

int GetFreeVoice()
{
	for (size_t i = 0; i < NUM_VOICES; i++)
	{
		if (!IsVoiceAllocated[i])
		{
			IsVoiceAllocated[i] = true;
			return i;
		}
	}

	return -1;
}

void HandleButtons()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		if (ButtonState[i] && !LastButtonState[i])
		{
			Serial.printf("Button %u pressed: Current voice %u\n", i, ButtonVoiceAllocation[i]);

			//allocate a voice to this button if not already allocated
			if (ButtonVoiceAllocation[i] == -1)
			{
				ButtonVoiceAllocation[i] = GetFreeVoice();
				Serial.printf("Allocated %u\n", ButtonVoiceAllocation[i]);
			}
			//if we could allocate - play the note
			if (ButtonVoiceAllocation[i] != -1)
			{
				envelopes[ButtonVoiceAllocation[i]]->amplitude(1, AnalogValues[attackTime]);
				filters[ButtonVoiceAllocation[i]]->amplitude(1, AnalogValues[attackTimeFilter]);
				attackWait[ButtonVoiceAllocation[i]] = millis();
				noteTrigFlag[ButtonVoiceAllocation[i]] = true;

				uint32_t noteFinishTime = max(AnalogValues[attackTime] + AnalogValues[releaseTime] + AnalogValues[sustainLevel] + AnalogValues[decayTime], AnalogValues[attackTimeFilter] + AnalogValues[releaseTimeFilter] + AnalogValues[sustainLevelFilter] + AnalogValues[decayTimeFilter]);
				releaseWait[ButtonVoiceAllocation[i]] = millis() + noteFinishTime;
			}
		}
		else if (!ButtonState[i] && ButtonVoiceAllocation[i] != -1)
		{
			noteTrigFlag[ButtonVoiceAllocation[i]] = false;
			envelopes[ButtonVoiceAllocation[i]]->amplitude(0, AnalogValues[releaseTime]);
			filters[ButtonVoiceAllocation[i]]->amplitude(-1, AnalogValues[releaseTimeFilter]);

			//has the note finished
			if (millis() > releaseWait[ButtonVoiceAllocation[i]])
			{
				Serial.printf("Button %u note %u finshed\n", i, ButtonVoiceAllocation[i]);
				IsVoiceAllocated[ButtonVoiceAllocation[i]] = false;
				ButtonVoiceAllocation[i] = -1;
			}
		}
		if (ButtonState[i] && ButtonVoiceAllocation[i] != -1)
		{
			if (millis() - attackWait[ButtonVoiceAllocation[i]] > AnalogValues[attackTime] && noteTrigFlag[ButtonVoiceAllocation[i]]) {
				envelopes[ButtonVoiceAllocation[i]]->amplitude(AnalogValues[sustainLevel], AnalogValues[decayTime]);
			}
			if (millis() - attackWait[ButtonVoiceAllocation[i]] > AnalogValues[attackTimeFilter] && noteTrigFlag[ButtonVoiceAllocation[i]]) {
				filters[ButtonVoiceAllocation[i]]->amplitude(AnalogValues[sustainLevelFilter], AnalogValues[decayTimeFilter]);
			}
		}
	}
}

float GetValueWithDeadband(int address, float min, float max, float mid)
{
	float val = AnalogValues[address];

	if (val < 400)
	{
		float newf = mapfloat(val, 0, 399, min, mid);
		return newf;
	}
	if (AnalogValues[address] > 600)
	{
		float newf = mapfloat(val, 601, 1023, mid, max);
		return newf;
	}
	else
	{
		return mid;
	}
}

float DetuneFrequency(float f)
{
	return mapfloat(AnalogValues[voice_2_detune], 0, 1023, .875, 1.125) * f;
	//return GetValueWithDeadband(voice_2_detune, .875, 1.125, 1) * f;
}

void SetVoiceFrequencies()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		if (ButtonVoiceAllocation[i] != -1)
		{
			voices1[ButtonVoiceAllocation[i]]->frequency(notes[i] * DigitalValues[voice_1_octave]);
			voices2[ButtonVoiceAllocation[i]]->frequency(DetuneFrequency(notes[i] * DigitalValues[voice_2_octave]) * lfoModulation);
		}
	}
}

void SaveValues()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		LastButtonState[i] = ButtonState[i];
	}
}

void ShowLeds()
{
	for (int i = 0; i < NUM_LEDS; i++)
	{
		if (ButtonVoiceAllocation[i] != -1)
		{
			SetKeyLight(i, CHSV(min(255, lfoModulation * 10), 255, 255));
		}
		else
		{
			SetKeyLight(i, CRGB::Black);
		}
	}

	FastLED.show();
}

int GetOctave(float val)
{
	return MapSwitch(val, 11) + 1;
}

int GetVoiceWaveForm(float val)
{
	int index = MapSwitch(val, 3);
	return WaveForms[index];
}

int GetLFOWaveForm(float val)
{
	int index = MapSwitch(val, 4);
	return WaveForms[index];
}

long MapSwitch(long in, long outMax)
{
	long halfstripe = (1023 / outMax) / 2;
	return ((in + halfstripe) * outMax) / 1023;
}

void GetButtons()
{
	for (size_t i = 0; i < NUM_BUTTONS; i++)
	{
		ButtonState[i] = GetKeyInput(i);
	}
}